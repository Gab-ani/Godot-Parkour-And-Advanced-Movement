This is the second episode for the series.
This branch is not a part of "working project. It saved the state of things for the 1.5 episode about radical rework of our navigation methods. Currently the AreaAwareness class is dismantled and holds four method/stubs used to demonstrate different stages of algorithm development. In the latter branches I'll clear all that up.

-------------
Also for like three people who'll actually use the code, there are three knowhows I want to talk about, but including them into the vid was too lengthy.
1) API for raycasting holds the bait telling you that raycast result array holds a value that straight up returns you an id of the face on the collider it hit. This is a bait. The id of the face is in fact consistent with the mesh, but this is an id of a triangulated face. Imagine a triangulated quad that holds a ledge as it's top edge. The quad is split by triangulation diagonal. If your ray hits the bottom half, your face id is the id of bottom triangle face. And it has three edges, but none of those is your target edge. Our tech with keying by face normals is immune to triangulation (in fact I even delete triangulation edges from our data because we don't use them).
2) You can see that I in fact don't use the normal to a face as a key. Instead I use a very similar vector that has all three components rounded to two digits post dot. The reason I do this is because the normal that you get by physically colliding a ray with a shape is one vector, but the normal of the mesh's face - is the different normal. They are very similar, but they can have a difference in up to three digits post dot. Hence, I cut those to be able to actually query by them. This doesn't introduce any false negatives or positives, at worst we'll process 8 edges instead of 4 if somehow two of our faces are different, but have the same rounded normal. But you can check how the angle between (1, 0, 0) and (-1.01, 0, 0) looks. I really doubt you'll have that angle between two faces of a collision model in a real game.
3) There is another topic I wanted to include, but cut out eventually. I demosntrated working times for methods near the monkey, and the last variation holds about 0.06-0.2 ms for execution. However, when you'll check the physics process near the monkey, it will still gain about 1 ms around it. The reason is the monkey is still a collision model, and our character's capsule wants to check collisions. In the top-notch practice, you must have two collision models. One on the character physical level, and there the monkey would be sphere + 2-3 aquariums. This will make it blazingly easy to collide with for your capsule. On the other layer, the navigation layer, there will be your raycasting done to get the mesh information. It isn't an overkill environment, I can perfectly imagine a real game. For example, a medieval home's collision can be like cube+piramid. But on mesh data collision layer it will have windows. Not for the capsule to go into them, but for the navigation to tell you there is a window and initiate the window-going process throug a route without the actual physical collision.
